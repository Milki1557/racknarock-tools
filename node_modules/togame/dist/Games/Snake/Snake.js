"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Snake = void 0;
const common_1 = require("../../common");
const ui_1 = require("../../ui");
const WIDTH = 18; // ÁîªÂ∏ÉÂÆΩ
const HEIGHT = 18; // ÁîªÂ∏ÉÈ´ò
const INTERVAL = 200; // interval
/**
 * Ë¥™ÂêÉËõá
 *
 * @export
 * @class Snake
 * @implements {IGame}
 */
class Snake {
    constructor() {
        this.ui = new ui_1.GameUI();
        /** ÂΩìÂâçüêçË∫´ */
        this.points = [];
        /** ÊñπÂêë üß≠ */
        this.direction = common_1.EDirection.RIGHT;
    }
    setup() {
        // ui
        this.ui.setup(WIDTH + 2, HEIGHT + 3);
        this.ui.on(common_1.EDirection.UP, () => {
            if (this.direction === common_1.EDirection.DOWN) {
                return;
            }
            this.direction = common_1.EDirection.UP;
        });
        this.ui.on(common_1.EDirection.DOWN, () => {
            if (this.direction === common_1.EDirection.UP) {
                return;
            }
            this.direction = common_1.EDirection.DOWN;
        });
        this.ui.on(common_1.EDirection.LEFT, () => {
            if (this.direction === common_1.EDirection.RIGHT) {
                return;
            }
            this.direction = common_1.EDirection.LEFT;
        });
        this.ui.on(common_1.EDirection.RIGHT, () => {
            if (this.direction === common_1.EDirection.LEFT) {
                return;
            }
            this.direction = common_1.EDirection.RIGHT;
        });
        this.ui.on('enter', () => {
            this.reset();
            this.start();
        });
        this.reset();
        this.ui.draw();
        // ÂÆöÊó∂Âô®
        this.start();
    }
    reset() {
        this.ui.hideGameOver();
        // points
        this.points = [{ x: 1, y: 1 }];
        // direction
        this.direction = common_1.EDirection.RIGHT;
        // food
        this.newFood();
    }
    run() {
        // check food, run
        this.checkFoodAndRun();
        // draw
        this.draw();
        // validate
        if (!this.validate()) {
            this.ui.showGameOver();
            this.stop();
            return;
        }
    }
    nextPoints() {
        switch (this.direction) {
            case common_1.EDirection.UP:
                return this.offsetPoint({ x: 0, y: -1 });
            case common_1.EDirection.DOWN:
                return this.offsetPoint({ x: 0, y: 1 });
            case common_1.EDirection.LEFT:
                return this.offsetPoint({ x: -1, y: 0 });
            default:
                return this.offsetPoint({ x: 1, y: 0 });
        }
    }
    offsetPoint(offset) {
        const fp = this.points[0];
        const np = {
            x: fp.x + offset.x,
            y: fp.y + offset.y
        };
        const queue = this.points.slice();
        queue.pop();
        queue.unshift(np);
        return queue;
    }
    validate() {
        const fail = this.points.some((p, index) => {
            // ÊòØÂê¶Á¢∞Â£Å
            const outside = p.x < 0 || p.x > WIDTH || p.y < 0 || p.y > HEIGHT;
            // ÊòØÂê¶Á¢∞Êíû
            const collision = this.points.some((p2, i2) => {
                return i2 !== index && p2.x === p.x && p2.y === p.y;
            });
            return outside || collision;
        });
        return !fail;
    }
    newFood() {
        const point = {
            x: ~~(Math.random() * WIDTH),
            y: ~~(Math.random() * HEIGHT)
        };
        // ‰∏çËÉΩÂá∫Áé∞Âú®ËõáË∫´‰∏ä
        if (this.points.some(p => p.x === point.x && p.y === point.y)) {
            this.newFood();
            return;
        }
        this.food = point;
    }
    checkFoodAndRun() {
        const np = this.nextPoints()[0];
        // ÂêÉÂà∞È£üÁâ©Ôºå‰∏çÂä®
        if (np.x === this.food.x && np.y === this.food.y) {
            this.points.unshift(np);
            this.newFood();
        }
        // Âê¶ÂàôÂâçËøõ‰∏ÄÊ≠•
        else {
            this.points = this.nextPoints();
        }
    }
    start() {
        this.stop();
        this.timer = setInterval(() => {
            this.run();
        }, INTERVAL);
    }
    stop() {
        clearInterval(this.timer);
    }
    draw() {
        this.ui.setRects([
            ...this.points,
            Object.assign(Object.assign({}, this.food), { color: '#f00' })
        ]);
        this.ui.setPromptContents([
            //
            'Game Snake',
            `Score: ${this.points.length - 1}`
        ]);
        this.ui.draw();
    }
    dispose() {
        this.stop();
        this.ui.dispose();
    }
}
exports.Snake = Snake;
